#include <Adafruit_NeoPixel.h>
#include <MPU6050_tockn.h>
#include <Wire.h>

// --- PIN CONFIGURATIE ---
#define PIN_LEDS_REAR   6  // Achterlicht strip
#define PIN_LEDS_FRONT  5  // Voorlicht strip
#define PIN_MOSFET      7  // Power LEDs

// Ingangs Knoppen
#define BTN_IN_POWER    2
#define BTN_IN_LEFT     3
#define BTN_IN_RIGHT    4

// Uitgangs Knoppen
#define BTN_LED_POWER   8
#define BTN_LED_LEFT    9
#define BTN_LED_RIGHT   10

// Aantal LEDs
#define CNT_REAR        36 // 3x12 Achter
#define CNT_FRONT       24 // 3x8 Voor

// --- OBJECTEN ---
Adafruit_NeoPixel stripRear(CNT_REAR, PIN_LEDS_REAR, NEO_GRB + NEO_KHZ800);
Adafruit_NeoPixel stripFront(CNT_FRONT, PIN_LEDS_FRONT, NEO_GRB + NEO_KHZ800);
MPU6050 mpu(Wire);

// --- KLEUREN ---
uint32_t C_OFF       = stripRear.Color(0, 0, 0);
uint32_t C_RED_DIM   = stripRear.Color(50, 0, 0);    // Rijden
uint32_t C_RED_MED   = stripRear.Color(150, 0, 0);   // Vertragen (Oplichten)
uint32_t C_RED_BRAKE = stripRear.Color(255, 0, 0);   // Remmen (Fel)
uint32_t C_ORANGE    = stripRear.Color(255, 140, 0);
uint32_t C_GREEN     = stripRear.Color(0, 255, 0);   
uint32_t C_WHITE     = stripFront.Color(255, 255, 255);

// --- GEVOELIGHEID INSTELLINGEN (ULTRA GEVOELIG) ---
// We hebben de drempel extreem laag gezet (0.03).
// Dit betekent dat uitbollen (windweerstand) al genoeg moet zijn.
float BRAKE_LIGHT = 0.03; // Vertragen (Uitbollen)
float BRAKE_HARD  = 0.25; // Echt remmen (Fel rood)
float BRAKE_STOP  = 0.50; // Noodstop (Knipperen)

// Filter (Smoothing)
// Iets trager gezet (0.15) om valse meldingen door trillingen te voorkomen
// nu de drempel zo laag is.
float FILTER_KRACHT = 0.15; 
float filteredAccel = 0;   

#define WIPE_SPEED 60
#define SCROLL_SPEED 80
#define FRONT_BOOT_BLINK_SPEED 250 

// --- VARIABELEN ---
bool systemOn = false;
int blinkState = 0; 

// Opstart Variabelen
bool isBooting = false;       
int loopsDone = 0;           
int scrollOffset = -12;      
unsigned long lastScrollTick = 0;
unsigned long lastFrontBlinkTick = 0;
bool frontBlinkState = false;

// Animatie variabelen
int wipeStep = 0;   
unsigned long lastWipeTick = 0;

// Remlicht variabelen
unsigned long lastStopFlashTick = 0;
bool stopFlashState = false;

// --- BITMAP VOOR "LUMA" ---
const byte lumaBitmap[3][18] = {
  {1,0,0, 0,  1,0,1, 0,  1,1,0,1,1, 0,  0,1,0}, 
  {1,0,0, 0,  1,0,1, 0,  1,1,1,1,1, 0,  1,1,1}, 
  {1,1,1, 0,  1,1,1, 0,  1,0,0,0,1, 0,  1,0,1}  
};

// --- MATRIX MAPPINGS ACHTER ---
int rearLeftAnim[4][3] = { {3,20,27}, {2,21,26}, {1,22,25}, {0,23,24} };
int rearRightAnim[4][3] = { {8,15,32}, {9,14,33}, {10,13,34}, {11,12,35} };

// --- MATRIX MAPPINGS VOOR ---
int frontLeftAnim[4][3] = { {3, 4, 11}, {2, 5, 10}, {1, 6, 9}, {0, 7, 8} };
int frontRightAnim[4][3] = { {12, 19, 20}, {13, 18, 21}, {14, 17, 22}, {15, 16, 23} };

void setup() {
  Serial.begin(115200);
  
  pinMode(BTN_IN_POWER, INPUT_PULLUP);
  pinMode(BTN_IN_LEFT, INPUT_PULLUP);
  pinMode(BTN_IN_RIGHT, INPUT_PULLUP);
  
  pinMode(BTN_LED_POWER, OUTPUT);
  pinMode(BTN_LED_LEFT, OUTPUT);
  pinMode(BTN_LED_RIGHT, OUTPUT);
  
  pinMode(PIN_MOSFET, OUTPUT);
  digitalWrite(PIN_MOSFET, LOW); 

  stripRear.begin(); stripRear.show();
  stripFront.begin(); stripFront.show();

  Wire.begin();
  mpu.begin();
  
  // HIER WORDT HET NULPUNT BEPAALD!
  // Zorg dat de fiets RECHT staat tijdens het opstarten.
  mpu.calcGyroOffsets(true); 
  Serial.println("Klaar.");
}

void loop() {
  mpu.update();

  // 1. AAN/UIT KNOP (LATCHING)
  bool currentPowerState = (digitalRead(BTN_IN_POWER) == LOW);

  if (currentPowerState && !systemOn) {
    systemOn = true;
    isBooting = true;           
    loopsDone = 0;              
    scrollOffset = -12;         
    frontBlinkState = false;    
  } 
  else if (!currentPowerState) {
    systemOn = false;
    isBooting = false;
  }

  // SYSTEEM UIT
  if (!systemOn) {
    digitalWrite(PIN_MOSFET, LOW);
    digitalWrite(BTN_LED_POWER, LOW);
    digitalWrite(BTN_LED_LEFT, LOW);
    digitalWrite(BTN_LED_RIGHT, LOW);
    stripRear.clear(); stripRear.show();
    stripFront.clear(); stripFront.show();
    return; 
  }

  // SYSTEEM AAN
  digitalWrite(BTN_LED_POWER, HIGH); 

  if (isBooting) {
    // --- FASE 1: OPSTART ANIMATIE ---
    digitalWrite(PIN_MOSFET, LOW); 
    handleStartupAnimation(); 
    if (loopsDone >= 1) {   
      isBooting = false; 
    }
  } 
  else {
    // --- FASE 2: NORMALE WERKING ---
    digitalWrite(PIN_MOSFET, HIGH); // Koplampen AAN

    // Pinker Knoppen Lezen
    if (digitalRead(BTN_IN_LEFT) == LOW) blinkState = 1;
    else if (digitalRead(BTN_IN_RIGHT) == LOW) blinkState = 2;
    else blinkState = 0;

    handleCombinedRearLight(); 
    handleFrontLight();
    handleButtonLeds();
  }

  stripRear.show();
  stripFront.show();
  delay(5);
}

// --- OPSTART ANIMATIE ---
void handleStartupAnimation() {
  if (millis() - lastFrontBlinkTick > FRONT_BOOT_BLINK_SPEED) {
    lastFrontBlinkTick = millis();
    frontBlinkState = !frontBlinkState; 
  }
  if (frontBlinkState) fillFront(C_GREEN); else fillFront(C_OFF);

  if (millis() - lastScrollTick > SCROLL_SPEED) {
    lastScrollTick = millis();
    scrollOffset++;
    if (scrollOffset > 18) { 
      scrollOffset = -12; 
      loopsDone++;        
    }
  }

  stripRear.clear();
  for (int col = 0; col < 12; col++) {
    int textColIndex = col + scrollOffset;
    if (textColIndex >= 0 && textColIndex < 18) {
      for (int row = 0; row < 3; row++) {
        if (lumaBitmap[row][textColIndex] == 1) {
          int ledIndex;
          if (row == 0) ledIndex = col;             
          else if (row == 1) ledIndex = 23 - col;    
          else ledIndex = 24 + col;                  
          stripRear.setPixelColor(ledIndex, C_GREEN);
        }
      }
    }
  }
}

// --- KNOP LAMPJES ---
void handleButtonLeds() {
  bool blinkOn = (wipeStep < 4);
  if (blinkState == 1) {
    digitalWrite(BTN_LED_LEFT, blinkOn ? HIGH : LOW);
    digitalWrite(BTN_LED_RIGHT, LOW);
  } else if (blinkState == 2) {
    digitalWrite(BTN_LED_LEFT, LOW);
    digitalWrite(BTN_LED_RIGHT, blinkOn ? HIGH : LOW);
  } else {
    digitalWrite(BTN_LED_LEFT, LOW);
    digitalWrite(BTN_LED_RIGHT, LOW);
  }
}

// --- GECOMBINEERD ACHTERLICHT ---
void handleCombinedRearLight() {
  
  // 1. DATA LEZEN
  float rawAccel = -mpu.getAccX(); 

  // 2. FILTEREN
  // 15% nieuwe waarde, 85% oude waarde voor stabiliteit
  filteredAccel = (filteredAccel * (1.0 - FILTER_KRACHT)) + (rawAccel * FILTER_KRACHT);

  // 3. BEPAAL KLEUR
  uint32_t currentBaseColor = C_RED_DIM; 

  if (filteredAccel > BRAKE_STOP) {
     // NOODSTOP (> 0.50G)
     if (millis() - lastStopFlashTick > 75) {
       lastStopFlashTick = millis();
       stopFlashState = !stopFlashState;
     }
     currentBaseColor = stopFlashState ? C_RED_BRAKE : C_OFF;
  } 
  else if (filteredAccel > BRAKE_HARD) {
    // HARD REMMEN (> 0.25G)
    currentBaseColor = C_RED_BRAKE; 
  } 
  else if (filteredAccel > BRAKE_LIGHT) {
    // VERTRAGEN / UITBOLLEN (> 0.03G)
    // Dit is extreem gevoelig. Als hij te vaak aangaat tijdens gewoon rijden,
    // verhoog BRAKE_LIGHT dan naar 0.05.
    currentBaseColor = C_RED_MED; 
  }

  fillRear(currentBaseColor);

  // 4. PINKER LOGICA
  if (blinkState == 0) return;

  if (millis() - lastWipeTick > WIPE_SPEED) {
    lastWipeTick = millis();
    wipeStep++;
    if (wipeStep > 6) wipeStep = 0; 
  }

  int (*currentAnim)[3];
  if (blinkState == 1) currentAnim = rearLeftAnim;
  else currentAnim = rearRightAnim;

  if (wipeStep < 4) { 
    for (int step = 0; step <= wipeStep; step++) {
      for (int i = 0; i < 3; i++) {
        stripRear.setPixelColor(currentAnim[step][i], C_ORANGE);
      }
    }
  }
}

// --- VOORLICHT LOGICA ---
void handleFrontLight() {
  fillFront(C_WHITE);
  if (blinkState == 1) { 
    for(int r=0; r<4; r++) for(int c=0; c<3; c++) stripFront.setPixelColor(frontLeftAnim[r][c], C_OFF);
    if (wipeStep < 4) {
      for (int step = 0; step <= wipeStep; step++) {
        for (int i = 0; i < 3; i++) stripFront.setPixelColor(frontLeftAnim[step][i], C_ORANGE);
      }
    }
  } 
  else if (blinkState == 2) {
    for(int r=0; r<4; r++) for(int c=0; c<3; c++) stripFront.setPixelColor(frontRightAnim[r][c], C_OFF);
    if (wipeStep < 4) {
      for (int step = 0; step <= wipeStep; step++) {
        for (int i = 0; i < 3; i++) stripFront.setPixelColor(frontRightAnim[step][i], C_ORANGE);
      }
    }
  }
}

void fillRear(uint32_t color) {
  for(int i=0; i<CNT_REAR; i++) stripRear.setPixelColor(i, color);
}

void fillFront(uint32_t color) {
  for(int i=0; i<CNT_FRONT; i++) stripFront.setPixelColor(i, color);
}
